Next js is a react framework which handles server side implementation



key features and benefits of NextJS

1. server side rendering i.e. preparing the contents of a page on the server instead of on the client.
- it greatly improves SEO as the page is automatically pre-rendered on the server, this improves load time and provide data to search engine crawlers as a typical react page only has an index.html file with not so much content
- blending client side and server sde. fetch data on the server and render finished pages

2. file based routing
- typically in react, we use react router where we define routes with code. in next js we define pages and routes with files and folders instead of code.
- this means less code, less work and easy to understand

3. Fullstack capabilities to our react app
- this helps with authentication, storing and fetching data etc



it is not possible to build a full feature rich app with react only as it is only responsible for building user interfaces


as a developer, you'll need to figure out ways of adding other features like routing, styling, authentication etc.


next js uses react for builing user interfaces and it comes loaded with features e.g routing, styling, authentication etc. that enable you to build a production ready application


next js simplifies the process of building a react app for production in the following ways
1. File based routing
2. pre rendering
3. API routes
4. support for css modules
5. authentication
6. dev and prod build system










??????QUESTION?????? create a new next js app called routing
??????QUESTION?????? what are the different ways that we can run a next js app.
??????QUESTION?????? run this project in dev mode
??????QUESTION?????? refactor your code to print Hello Next JS













~ npx create-next-app

this will then prompt you to enter the project name


the 3 most important files will be public for storing static files, styles and pages which is the most important


to run the project use npm run dev

npm run build is to build for production and npm start to run the production version


 ~ cd appName

 ~ npm run dev


 what we see on the screen is the result of index.js file in pages


 open index and delete everything inside the main div. print a h1 tag of Hello Next World










??????QUESTION?????? do the following clean up, in styles delete Home.module. replace the code in globals with the code below
@import url('https://fonts.googleapis.com/css2?family=Lato:wght@700&family=Open+Sans:wght@400;700&display=swap');

* {
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', 'Lato', sans-serif;
}

h1, h2, h3, h4, h5, h6 {
    font-family: 'Lato', sans-serif;
}

??????QUESTION?????? in pages delete everything except _app.js
??????QUESTION?????? when a user goes to / print on the screen this is the home page and when a user goes to /about print on the screen this is the about page
??????QUESTION?????? assuming we have a portfolio with several projects, set up a route /portfolio for the default portfolio page and /portfolio/"projectId" for the projects. for now they should just print portfolio and projectId respectively












/////////////////////
PAGES AND FILE BASED ROUTING
/////////////////////




do the following clean up

in styles delete Home.module and update globals to contain the following code

@import url('https://fonts.googleapis.com/css2?family=Lato:wght@700&family=Open+Sans:wght@400;700&display=swap');

* {
    box-sizing: border-box;
}

body {
    font-family: 'Open Sans', 'Lato', sans-serif;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: 'Lato', sans-serif;
}


in pages delete everything except _app.js

in a traditional react app, we use react router for our routing


in next js we create react component files in the pages folder and let next js infer the routes from the folder structure


it takes the file name as part of the url e.g. if we had inside our pages folder a file called about.js, this will mean www.domain.com/about


inside pages, create a file called index.js which will be the default page for /


we will write a regular react component here and export it

const HomePage = () => {
    return(
        <div>
            <h1>The Home Page</h1>
        </div>
    )
}

export default HomePage


when we visit /, our screen should print The Home Page



create a new file in pages called about.js

const About = () => {
    return(
        <div>
            <h1>The About Page</h1>
        </div>
    )
}

export default About

visiting /about will show this component


we can also have nesting in pages. create a folder called portfolio


inside these folder, the default file is index.js which will show when the user navigates to /portfolio


we can also have placeholders where we can use to pass things like ids. we only need to enclose them in [square brackets].js


/portfolio/index.js

const Portfolio = () => {
    return(
        <div>
            <h1>Portfolio</h1>
        </div>
    )
}

export default Portfolio


/portfolio/[projectId].js

const ProjectId = () => {
    return(
        <div>
            <h1>ProjectId</h1>
        </div>
    )
}

export default ProjectId


it is also possible to have a dynamic folder in [square brackets] and nest other files inside it including a dynamic file

















??????QUESTION?????? console log the value passed into the url in [projectId].js













we can get access to the dynamic value passed into our projectId url by using useRouter which is a react hook we import from nextjs

import {useRouter} from "next/router";


const router = useRouter()

this will return an object which has several methods which we will look at later in the course and we also get data properties


for the data properties, we get the following

router.pathname - /portfolio/[projectId]
router.query - {projectId: 5}













??????QUESTION?????? assuming we have a blog post where we can pass several query parameters. the number of queries passed changes based on what we want to search for e.g.
/blog/2020
/blog/2020/12
/blog/2020/12/4
implement this and console log the dynamic values of the url in our component















we will now look at catch all routes


assuming we have a blog post where we can pass several query parameters. the number of queries passed changes based on what we want to search for e.g.

/blog/2020      - will filter blogs for 2020
/blog/2020/12      - will filter blogs for 2020 december
/blog/2020/12/4      - will filter blogs for 2020 december 4th blog post


in order to implement this dynamic url, we will use catch all


create a folder called blog and create a file called [...slug]

import {useRouter} from "next/router";

const BlogPost = () => {

    const router = useRouter()

    console.log(router.query);

    return(
        <div>
            <h1>Blog Posts</h1>
        </div>
    )
}

export default BlogPost


router.query will console log an array with all the dynamic parts of the url as items in the array



















??????QUESTION?????? in our main index.js file, create an ul which will contain links to the about page and portfolio/index page
??????QUESTION?????? add links in portfolio/index that will go to project ids using the projects below

    const projects = [
        {id: 1, name: "bc-vote"},
        {id: 2, name: "amazon-cellular"},
        {id: 3, name: "netflix clone"}
    ]












we will now create links in our main index.js file to the other parts of our app i.e. about and portfolio


we can use a tags but this will be against react principles as it will cause the whole page to refresh


we will use Link component which we will import form next/link


import Link from "next/link";


    <ul>
        <li>
            <Link href="/about">About</Link>
        </li>
        <li>
            <Link href="/portfolio">Portfolio</Link>
        </li>
    </ul>




we will now add links in portfolio/index that will go to project ids

    const projects = [
        {id: 1, name: "bc-vote"},
        {id: 2, name: "amazon-cellular"},
        {id: 3, name: "netflix clone"}
    ]

    const renderProjects = () => {
        return projects.map(
            project => {
                return(
                    <li key={project.id}>
                        <Link href={`/portfolio/${project.id}`}>{project.name}</Link>
                    </li>
                )
            }
        )
    }














??????QUESTION?????? use the alternative syntax of passing the href in a next js Link in portfolio/index











building a string like href={`/portfolio/${project.id}`} can be tiresome and annoying. next js provides us with a better alternative


instead of passing a string, you can pass an object


        <Link
            href={{
                pathname: "/portfolio/[id]",
                query: {id: project.id}
            }}
        >
            {project.name}
        </Link>

these are the same pathname and query variables that we saw when we console logged useRouter















??????QUESTION?????? using programmatic navigation create a button in portfolio that takes the user back to the home page












we can also use useRouter to perform programmatic navigation

we will create a button in portfolio that takes the user back to the home page

    const goHome = () => {
        router.push("/")
    }

<button onClick={goHome}>Home page</button>


we can not only use a string for the url but also the object method

    const goHome = () => {
        router.push({
            pathname: "/"
        })
    }














??????QUESTION?????? create a custom 404 page which prints out Page not found














next js provides a default 404 page. this shows when we go to an unavailable link


we can also create a custom 404 page


inside pages, create a 404.js file


const PageNotFound = () => {
    return(
        <div>
            <h1>Page Not Found</h1>
        </div>
    )
}

export default PageNotFound















??????QUESTION?????? create a new next app called prerendering
??????QUESTION?????? what are the two forms of pre rendering supported by next js
??????QUESTION?????? which is the default method of pre rendering in next js
??????QUESTION?????? do the necessary clean up to the project and print home page in index
??????QUESTION?????? create a new file route to /users which will print out List of users
 ??????QUESTION?????? fetch the name and email of users  from https://jsonplaceholder.typicode.com/users and print them out in /users. HINT!! use best practise and project structure












////////////////////////////
PRE RENDERING AND DATA FETCHING
////////////////////////////



~ npx create-next-app prerendering


by default, next js pre renders every page in the application


pre-rendering improves performance and SEO


next js supports two forms of pre rendering
1. static generation
2. server side rendering


static generation is where the HTML pages are generated at build time


HTML with all the data that makes uo the content of the web page are generated in advance when when you build your application


this is the recommended method to pre render whenever possible as pages can be built once, cached by a CDN and served to the client almost instantly


examples include blog pages, e-commerce product pages, documentation and marketing pages


by default, the html for every page will automatically be statically generated when we build our application


static generation can be done with or without data fetched externally. in the case that data needs to be fetched, the html can only be generated (pre rendered) after fetching data


in styles delete Home, in pages delete the api folder and the content of the index file with a simple h1 tag


we will look at how to fetch data statically ahead of time. we will fetch a list of users from the JSON Placeholder api


in pages, create a new file called users.js

const UsersList = () => {
    return(
        <h1>List of users</h1>
    )
}

export default UsersList


in next js when exporting a page component, you can also export an async function called getStaticProps which will run at build time in production and inside the function you can fetch external data and send it as props to the page

import axios from "axios";

const UsersList = ({users}) => {
    return(
        <>
            <h1>List of users</h1>
            {users.map(
                user => {
                    return(
                        <div key={user.id}>
                            <p>{user.name}</p>
                            <p>{user.email}</p>
                        </div>
                    )
            })}
        </>
    )
}

export default UsersList

export async function getStaticProps() {
    const response = await axios.get("https://jsonplaceholder.typicode.com/users")
    console.log(response.data);
    return{
        props:{
            users: response.data
        }
    }
}


the console log shows in the server terminal and not in the browser like react


we also need to return from getStaticProps and object which contains a key props. the key props should be an object too with key value pairs of the data we want to pass into our component


this works well, however it is not how you would write a production application. the printing out of details of a user should be done by a separate user component


in project root, create a folder called components and inside it create a new file called user.js

const User = ({user}) => {
    return(
        <div>
            <p>{user.name}</p>
            <p>{user.email}</p>
        </div>
    )
}

export default User


we will import this in users.js and use it in our map

    <div key={user.id}>
        <User user={user} />
    </div>


with this we can see the difference between pages and components. components don't need the special routing features provided in next js













we will now look at a few important details of the getStaticProps function we had used in users.js


1. getStaticProps only runs on the server side. the code won't even be included in the bundle.js file sent to the browser


2. with this we can write server side code directly in getStaticProps e.g. accessing the file system, querying a db


3. this is allowed only in a page and cannot be run from a regular component file


4. getStaticProps should return an object and the object should contain a props key which is also an object containing key value pairs of data we want to pass to the page component

return{
    props:{
        users: usersArray
    }
}


5. getStaticProps will run at build time












??????QUESTION?????? run our prerendering app in production mode and inspect the terminal and the folders created
??????QUESTION?????? in pages/index, create a link to users.js. rebuild the project and run it again
??????QUESTION?????? run the code in your browser, open the network tab, hard reload and look at the resources received from the server when hard reloading / and /users. explain the difference between the first run above and this second run after adding the users link














we will now look at how to build our next js application and take a look at the build output to understand the static generation form of pre rendering more


in our root folder, we have a .next folder which is created automatically when we run our project in dev mode. we will delete this as running our project in production mode will also automatically create a new .next file


after deleting, run npm run build in the terminal


the output of this is the types of pages created e.g. static, SSG and the sizes of the pages. green colors on the sizes show they're optimum


inside out automatically created .next folder, the important files to look at are /server and /static


/server contains a pages folder which will contain all the html files generated with some js files


/static/chunks contains a pages folder too which will contain js files necessary for hydration i.e. making our html files responsive


we will now run our build application using the start script

~ npm start


if we open this in our browser network tab, we will note that going to / loads the index chunk and /users loads the users chunk


however if we add a link to /users in index, rebuild and run again, we will note that in the network tab, going to / loads the index and users chunk as well as it is linked


the advantage to this is that when we go to /, navigating to /users will be instantaneous as we would have already loaded the users chunk


this is the default behaviour of next js. any <Link> component in the viewport (initially or through scroll) will be prefetched by default (including the corresponding data) for pages using Static Generation


when a page with getStaticProps is pre rendered at build time, in addition to the page HTML file, next.js generates a json file holding the result of running getStaticProps


this file will be used in client side routing through next/link or next/ router which is what is happening in our case. our index contains a link to users therefore going to / loads the users data. going to /users directly will instead use the users.html file generated at build time


in simpler terms, client side page transitions will not call getStaticProps as only the exported json is used



create pages/posts/index.js

















??????QUESTION?????? in pages, create a folder called posts and inside it index.js and [postId]. we will use these tp statically generate dynamic data
??????QUESTION?????? in index.js fetch the first 3 posts from https://jsonplaceholder.typicode.com/posts. print the post id and title on the screen using h2
??????QUESTION?????? [postId].js should print out the details of a specific post i.e. post id, title and body
??????QUESTION?????? wire up links from root index.js to [postId].js and test this out on the browser









our index page pre renders without data
users page pre renders after fetching data from an external api
we will now look at how to statically generate pages (default pre rendering) using dynamic data


we will use the example of a blog post which containing a list and a dynamic blogId which shows the details of a blog post


we will use jsonplaceholder /posts and /posts/1


create a folder in pages called posts and inside it create index.js which is going to be our post list component fetching from jsonplaceholder /posts using getStaticProps


we will only use the first 3 posts for simplicity using .slice(0,3)


const Posts = ({posts}) => {
    return(
        <div>
            PostList
            {posts.map(
                post => {
                    return(
                        <div key={post.id}>
                            <h2>{post.id} {post.title} </h2>
                            <hr/>
                        </div>
                    )
                }
            )}
        </div>
    )
}

export default Posts

export async function getStaticProps() {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts")

    return {
        props: {
            posts: response.data.slice(0,3)
        }
    }
}





in the pages folder create [postId].js to show a specific post which we will also prerender data we're fetching from https://jsonplaceholder.typicode.com/posts/postId


we will extract the post id from the url. in order to get access to the url params, getStaticProps receives an argument by convention called context which is an object containing a key called params which is also an object containing postId

function Post({post}) {
    return(
        <>
            <h2>{post.id} {post.title}</h2>
            <p>{post.body}</p>
        </>
    )
}

export default Post

export async function getStaticProps(context) {
    const {params} = context
    const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${params.postId}`)
    return{
        props: {
            post: response.data
        }
    }
}



the last thing will be to add links from the home page to the post id page

root index.js

    <Link href="/posts">Posts</Link>


post index.js

    <Link href={`/posts/${post.id}`}>
        <h2>{post.id} {post.title} </h2>
    </Link>


if we try to run this in the browser, everything runs well but we get an error in /posts/[postId] getStaticPaths is required for dynamic SSG pages and is missing for '/posts/[postId]'


a dynamic parameter means we wont be having a single page. the html will remain the same but the data will differ for every postId


next.js is basically telling us to tell it what postIds to consider when generating the pages at build time which is done using the getStaticPaths function


[postId].js we will define getStaticPaths which returns an object containing a paths key which determines which paths will be statically generated at build time

paths is an array containing objects with key params which are all the paths that will be considered during build

the value of params will be an object of postId with the Ids passed as strings

the return object contains another key called fallback which we will discuss later. for now we will just set its value to false


export async function getStaticPaths() {

    return{
        paths: [
            {
                params: {postId: "1"}
            },
            {
                params: {postId: "2"}
            },
            {
                params: {postId: "3"}
            }
        ],
        fallback: false
    }
}




















??????QUESTION?????? instead of 3 posts, fetch all the posts we get from our api and wire them up in our app












our app works well however there's an issue with our getStaticPaths function. we had hardcoded the 3 params to match the 3 posts that we had fetched


this isn't practical in a real world situation though


in posts getStaticProps, remove the slice method

[postId].js

export async function getStaticPaths() {

    const response = await axios.get("https://jsonplaceholder.typicode.com/posts")

    const pathsArray = response.data.map(
        post => {
            return {
                params: {
                    postId: `${post.id}`
                }
            }
        }
    )

    return{
        paths: pathsArray,
        fallback: false
    }
}















??????QUESTION?????? what are the different values that we can pass to the fallback key in getStaticPaths
??????QUESTION?????? what happens when we use false and which scenario is most suitable to use false














we will now look at the fallback key returned from getStaticPaths


it is mandatory to add this key thats why we included it and set its value to false


it accepts 3 possible values

1. false
2. true
3. 'blocking'


at the moment, our getStaticPaths function is accommodating for urls from /posts/1 to /posts/100


when the value of getStaticPaths fallback is set to false:

- the paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps
- any paths not returned by getStaticPaths will result in a 404 page


the false value is most suitable if you have an application with a small number of paths to pre-render and new pages are not added often. a blog site with a few articles is a good example for fallback set to false















??????QUESTION?????? explain what happens when fallback is set to true
??????QUESTION?????? change the code to fetch for 3 posts instead of the 100 posts, modify posts/index.js and [postId].js
??????QUESTION?????? set fallback to true and make the necessary changes in [postId].js to support the fallback page which can simply be a Loading... text
??????QUESTION?????? in the case a user enters an invalid url to post/postId, display the 404 page. build and run this in the browser
??????QUESTION?????? in what scenarios would fallback true be most applicable














when the value of getStaticPaths fallback is set to true:

- the paths returned from getStaticPaths will be rendered to HTML at build time by getStaticProps
- the paths that have not been generated at build time will not result in a 404. instead next.js will serve a fallback version of the page on the first request to such a path
- in the background, next js will statically generate the requested path html and json. this includes running getStaticProps
- when that's done, the browser receives the json for the generated path. this will be used to automatically render the page with the required props. from the user's perspective, the page will be swapped from the fallback page to the full page
- at the same time, next.js keeps track of the new list of pre rendered pages. subsequent requests to the same path will serve the generated page just like other pages pre rendered at build time



change the code to fetch for 3 posts instead of the 100 posts

posts/index.js

posts: response.data.slice(0,3)

[postId].js

getStaticPaths function

    return{
        paths: [
            {params: {postId: "1"}},
            {params: {postId: "2"}},
            {params: {postId: "3"}}
        ],
        fallback: true
    }


we will also need to modify our post component to support fallback true

import {useRouter} from "next/router";
...

    const router = useRouter()

    if (router.isFallback){
        return <h1>Loading...</h1>
    }


build and run the project



the paths that have not been generated at build time will not result in a 404 page. instead next.js will serve a fallback version of the page on the first request to such a path


our app now supports posts/1 - 3 and we don't see the loading text on the ui


when we visit /posts/4, we see the loading text briefly then posts/4 is fetched from the api


the loading text is our fallback page which we see instead of the 404 page on the initial request


while this is shown, next.js in the background is statically generating the requested path html and json. this includes running getStaticProps which fetches and pre renders the 4th post


when that's done, the browser receives the json for the generated path. this will be used to automatically render the page with the required props. from the user's perspective, the page will be swapped from the fallback page to the full page


at the same time, next.js keeps track of the new list of pre rendered pages. subsequent requests to the same path will serve the generated page just like other pages pre rendered at build time


in the case that a user makes a request to an invalid postId, we would want to return a 404 page instead which is so easy using next.js


in getStaticProps, if our response isn't what we want we can return an object with a notfound property set to true. and if this is the case, next js will automatically render the 404 page

export async function getStaticProps(context) {
    const {params} = context

    try {
        const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${params.postId}`)

        return{
            props: {
                post: response.data
            }
        }
    } catch (e) {
        return{
            notFound: true
        }
    }
}


build and run again



fallback set to true is most suitable if your app has a very large number of static pages that depend on data


e.g. a large e-commerce site. you want all the product pages to be pre rendered but if you have a few thousand products, builds can take a really long time


instead you may statically generate a small subset of products that are popular and use fallback true for the rest












??????QUESTION?????? what happens when we use fallback blocking
??????QUESTION?????? update the code to use fallback blocking
??????QUESTION?????? in what cases would you use fallback blocking
??????QUESTION?????? which is the recommended fallback method in next.js












fallback blocking is very similar to fallback true. the only difference is that instead of showing a fallback page, you will not see any new content in the ui while the page is being generated on the server


- the paths returned from getStaticPaths will be rendered to html at build time by getStaticProps
- the paths that have not been generated at build time will not result in a 404 page. instead on the first request, next.js will render the page on the server and return the generated html
- from the user's perspective, it will transition from "the browser is requesting the page" to "the full page is loaded". there's no fallback stage
- next.js keeps track of the new list of pre rendered pages. subsequent requests to the same path will serve the generated page just like the other pages pre rendered at build time



we will then remove the useRouter and fallback code as we don't need it anymore


rebuild and run the app again


we will notice that when we go to a page that hasn't been pre-rendered yet, the loading time is quite significant. the browser also looks like it is loading (the refresh button is spinning). however, there's nothing to show in the ui as it transitions to the full page



fallback "blocking" is used as on a ux level, sometimes people prefer the page to be loaded without a loading indicator if the wait time is a few milliseconds. this helps avoid the layout shift/ changes in the ui


however, the technical reason that blocking was introduced was that some website crawlers did not support js. the loading page would be rendered and then the full page would be loaded which would cause a problem


next.js recommends fallback true unless you see a problem with it in that case you would use "blocking"














??????QUESTION?????? what are two common issues of static generation
??????QUESTION?????? how can the issue of stale/ outdated data be solved
??????QUESTION?????? what is ISR and how does it work
??????QUESTION?????? use ISR for the getStaticProps function below
export async function getStaticProps() {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts")

    return {
        props: {
            posts: response.data
        }
    }
}











getStaticProps for data fetching and getStaticPaths for dynamic pages seem like a really good approach to a wide variety of apps in production


however, static generation comes with issues as well
1. the build time is proportional to the number of pages in the application
2. a page, once generated, can contain stale data till the time you rebuild the application again. stale data can occur in the case that some data was updated after build. the app will still be showing the old outdated version of the data until the next rebuild


there was a need to update only those pages which needed a change without having to rebuild the entire app


to solve this, next js introduced INCREMENTAL STATIC REGENERATION (ISR) which allows you to update static pages after you've built your application


in order to use incremental static generation, in the getStaticProps return statement, apart from the props key, we can specify a revalidate key


the value for revalidate is the number of seconds after which a page re-generation can occur

    return {
        props: {
            posts: data
        },
        revalidate: 10
    }


when the revalidate time expires, when a user reaches the target url, they're still served the stale data however a regeneration happens in the background. when they access the same url again, they will be served by the new data page


a re-generation is initiated only if a user  makes a request after the revalidate time


revalidate doesn't mean that the page automatically re-generates every 10 seconds but the time after which a request initiates a re-generation


the re-generation can also fail and the previously cached html could be served till the subsequent re-generations succeed


this is a good pre rendering solution. however, there can be situations where we can't afford to serve stale data even for a second. this is why we use server side rendering












??????QUESTION?????? what are the issues of static generation
??????QUESTION?????? install json-server, npm i json-server
??????QUESTION?????? create a new file called db.json which will contain the code below
 {
   "news": [
     {
       "id": 1,
       "title": "News Article 1",
       "description": "Description 1",
       "category": "sports"
     },
     {
       "id": 2,
       "title": "News Article 2",
       "description": "Description 2",
       "category": "politics"
     },
     {
       "id": 3,
       "title": "News Article 3",
       "description": "Description 3",
       "category": "sports"
     }
   ]
 }
??????QUESTION?????? add a start script to package.json "serve-json": "json-server --watch db.json --port 4000" and start the json-server in a new terminal window
??????QUESTION?????? create a new route to /news which will display a list of news articles pre-rendered using SSR















////////////////////////////////////////
SERVER SIDE RENDERING
////////////////////////////////////////



SSR is the second form of pre rendering other than static generation


as mentioned earlier, static generation pre-renders a page at build time (with exception to getStaticPaths which pre-renders on initial request and ISR which re-generates and pre-renders the pages when the validation time expires)


we looked at the issues of static generation
1. we cannot fetch data at request time and we can have stale data
2. we don't get access to the incoming request. this becomes a problem when the data that needs to be fetched is specific to a user


to overcome these problems, next js offers server side rendering (SSR) which pre-renders a page at request time and not at build time


it also provides SEO capabilities which aren't possible in client side rendering


we will assume that we're building a news website where we will display a list of news articles that we will fetch from an api (jsonserver)



~ npm i jsonserver


in project root, create a file called db.json and add the following code

 {
   "news": [
     {
       "id": 1,
       "title": "News Article 1",
       "description": "Description 1",
       "category": "sports"
     },
     {
       "id": 2,
       "title": "News Article 2",
       "description": "Description 2",
       "category": "politics"
     },
     {
       "id": 3,
       "title": "News Article 3",
       "description": "Description 3",
       "category": "sports"
     }
   ]
 }


add a start script in package.json

"serve-json": "json-server --watch db.json --port 4000"


~ npm run serve-json


we will now create the news list page which will use the SSR form of pre rendering


in pages, create a new folder called news and inside it create a new file called index.js

function NewsArticlesList() {
    return(
        <div>
            <h1>List of News Articles</h1>
        </div>
    )
}

export default NewsArticlesList



to prerender using ssr, we export an async function called getServerSideProps. this will be called by the server on every request


inside this function, we can fetch external data and send it as props to the component

export async function getServerSideProps() {
    const response = await axios.get("http://localhost:4000/news")

    return {
        props: {
            articles: response.data
        }
    }
}



we will then get articles passed in as props in our component and map over the articles to print them on the screen

    <div>
        <h1>List of News Articles</h1>
        {articles.map(article => {
            return(
                <div key={article.id}>
                    <h2>{article.id} {article.title} | {article.category}</h2>
                </div>
            )
        })}
    </div>


this form of pre rendering is slower than static generation as the server must compute every request and because of this only use SSR when absolutely necessary

notes on getServerSideProps

1. getServerProps only runs server side and code won't be included in the js bundle

2. we can also write server side code like accessing the file system in server side code

3. get server side prop is only allowed in a page and can't be run from a regular component

4. should return an object with property props which will be an object containing data we want to pass to the component

5. getServerSideProps will run at request time


















??????QUESTION?????? create a page that filters news articles by the category passed in the url e.g /news/sports should show all sports articles














we will now look at how to SSR with dynamic parameters


we want a page that filters news articles by category


we will create a route /news/category where category will be a specific category passed in the url and it will display only articles matching that category e.g. /news/sports will display article 1 and 3


in the news folder create [category].js


to fetch the filtered articles, we will need getServerSideProps


also not that if we query http://localhost:4000/news?category=sports to our json server, it will only return sports articles only


knowing this, we can extract the [category] passed in the url and query the searched term in our json server. this is done in the same way as getStaticProps where the first argument by convention called context in our function contains a params key with all the parameters in our url


in our return function, we will also pass category as a prop

import axios from "axios";

function ArticlesByCategory({articles, category}) {
    return(
        <div>
            <h1>List of {category} articles</h1>
            {articles.map(article => {
                return(
                    <div key={article.id}>
                        <h2>{article.id} {article.title}</h2>
                        <p>{article.description}</p>
                        <hr/>
                    </div>
                )
            })}
        </div>
    )
}

export default ArticlesByCategory

export async function getServerSideProps(context) {
    const {params} = context
    const {category} = params
    const response = await axios.get(`http://localhost:4000/news?category=${category}`)

    return{
        props: {
            articles: response.data,
            category
        }
    }
}










??????QUESTION?????? what are some of the other useful objects we can get from the context object in getServerSideProps
??????QUESTION?????? build the project and run. what are the differences between static generation and server side rendering










we had mentioned earlier that one of the limitations of static generation is that you dont get access to the incoming request which can affect you for example in fetching data that is user specific


we can achieve this in SSR as these are passed into the context object in getServerSideProps where apart from params we also get req and res


req is a standard http incoming message object and res is a standard http response object (like express.js)


another useful object we get from context is the query object which gives us access to the query string


we will now inspect the build output in SSR

~ npm run build

our SSR pages will get the λ symbol

also not that in SSR, html pages are not generated at build time. if we inspect .next/server/news,  we won't find any html pages


~ npm start


if we visit a page, it will be pre-rendered on request and even after this the html file is not generated in the server folder as the pages are generated on request











??????QUESTION?????? add the following code to db.json
??????QUESTION?????? create a route to /dashboard which will do client side rendering to display posts, likes, followers and following from db.json. Display a loading text in the case data hasn't been fetched yet i.e. when it is fetching










we will now look at client side data fetching


when building an application, you might not always need to pre-render data e.g. a dashboard page which is behind a login screen so no need of SEO and is highly user specific


add the following code to our db.json

 "dashboard": {
    "posts": 5,
    "likes": 100,
    "followers": 20,
    "following": 50
  }

fetching data on client side is going to be exactly the same as in react


in pages, create dashboard.js


import {useState, useEffect} from "react";
import axios from "axios";

function Dashboard() {
    const [loading, setLoading] = useState(true)
    const [dashboardData, setDashboardData] = useState(null)

    useEffect(() => {
        fetchDashboardData()
    }, [])

    const fetchDashboardData = async () => {
        const response = await axios.get("http://localhost:4000/dashboard")

        setDashboardData(response.data)
        setLoading(false)
    }

    if (loading) {
        return <h1>Loading....</h1>
    }

    const {posts, likes, followers, following} = dashboardData

    return (
        <div>
            <h1>Dashboard</h1>
            <h2>Posts - {posts}</h2>
            <h2>Likes - {likes}</h2>
            <h2>Followers - {followers}</h2>
            <h2>Following - {following}</h2>
        </div>
    )
}

export default Dashboard

















??????QUESTION?????? create a new route /dashboard-swr and perform data fetching using swr
??????QUESTION?????? what are some of the advantages of using swr?

















so far we have been using axios to perform our data fetching. the next.js developers created SWR for client side data fetching


SWR stands for Stale While Revalidate which is basically a react hook for data fetching


it handles caching, revalidation, focus tracking, refetching on intervals and a lot more


in the terminal, run
~ npm add swr


in pages, create dashboard-swr.js


the first argument is a unique key for the request, the second argument is a function where we fetch the data and return it. it a common practise to call this function fetcher


this hook returns data and error which we can destructure

import useSWR from "swr"
import axios from "axios";

function DashboardSWR() {
    const fetcher = async () => {
        const response = await axios.get("http://localhost:4000/dashboard")
        return response.data
    }

    const {data, error} = useSWR('dashboard', fetcher)

    if (error) return <h1>An error occured!</h1>
    if (!data) return <h1>Loading...</h1>

    const {posts, likes, followers, following} = data

    return (
        <div>
            <h1>Dashboard</h1>
            <h2>Posts - {posts}</h2>
            <h2>Likes - {likes}</h2>
            <h2>Followers - {followers}</h2>
            <h2>Following - {following}</h2>
        </div>
    )
}

export default DashboardSWR




if we run this in the browser /dashboard-swr


data fetching with swr is much simpler than axios, useState and useEffect hooks. the code is much cleaner


also if we change something in db.json e.g. likes to 150, on /dashboard, we have to refresh the page for changes to take place. however, in /dashboard-swr, it automatically fetches the new data without needing to refresh














??????QUESTION?????? follow the instructions below









we will now look at how to combine pre rendering and client side data fetching


for this, we're going to build an event listing page which shows a list of events happening around a user


since we want SEO and request time data fetching, we will use SSR with getServerSideProps


once the events have been loaded, we're going to use client side data fetching for filtering events


ideally, both pagination and filtering would be done on client side but for this example we're only going to focus on filtering


add the following code to db.json

"events": [
    {
      "id": 1,
      "title": "Event 1",
      "description": "Description 1",
      "category": "sports",
      "date": "April 25"
    },
    {
      "id": 2,
      "title": "Event 2",
      "description": "Description 2",
      "category": "technology",
      "date": "May 25"
    },
    {
      "id": 3,
      "title": "Event 3",
      "description": "Description 3",
      "category": "food",
      "date": "October 25"
    },
    {
      "id": 4,
      "title": "Event 4",
      "description": "Description 4",
      "category": "food",
      "date": "April 25"
    },
    {
      "id": 5,
      "title": "Event 5",
      "description": "Description 5",
      "category": "sports",
      "date": "January 15"
    },
    {
      "id": 6,
      "title": "Event 6",
      "description": "Description 6",
      "category": "art",
      "date": "April 25"
    },
    {
      "id": 7,
      "title": "Event 7",
      "description": "Description 7",
      "category": "technology",
      "date": "June 25"
    },
    {
      "id": 8,
      "title": "Event 8",
      "description": "Description 8",
      "category": "sports",
      "date": "February 28"
    },
    {
      "id": 9,
      "title": "Event 9",
      "description": "Description 9",
      "category": "food",
      "date": "April 25"
    },
    {
      "id": 10,
      "title": "Event 10",
      "description": "Description 10",
      "category": "sports",
      "date": "August 5"
    }
  ]
















??????QUESTION?????? in pages, create events.js which will fetch a list of all the events using SSR. map through this list and print the id, title, date, category, description for each event
??????QUESTION?????? create a button at the top of the page which filters only events with the category sport. use client side data fetching and filtering using query parameters for this. also make sure the url updates to /events?category=sports when the button is clicked













in pages, create events.js


this will display all the events and the first task will be to fetch data required for server side rendering

export async function getServerSideProps() {
    const response = await axios.get("http://localhost:4000/events")

    return{
        props: {
            events: response.data
        }
    }
}


we will then map through the events array

    <div>
        <h1>List of events</h1>
        {events.map(event => {
            const {id, title, date, category, description} = event
            return(
                <div key={id}>
                    <h2>
                        {id} {title} {date} | {category}
                    </h2>
                    <p>{description}</p>
                </div>
            )
        })}
    </div>


after we have rendered the list, we want to allow the user to filter the events based on the category


ideally we would have a navbar which a user would select the category they want to filter but to keep things simple we will only use one button which filters sports category


we will create this button after the root div

<div>
    <button onClick={fetchSportsEvents}>Sports Events</button>
    <h1>List of events</h1>


within this function, we will fetch the list of filtered events. after filtering this data, we will store it in a state variable to make the component rerender

    const [stateEvents, setStateEvents] = useState(events)

    const fetchSportsEvents = async () => {
        const response = await axios.get("http://localhost:4000/events?category=sports")
        setStateEvents(response.data)
    }

we will then replace the rendered map to use stateEvents and not the props event


this works well, however the url doesn't update therefore we can't share this nor bookmark it


we can use this by using shallow routing which updates the url in the browser without running the code inside getServerSideProps


for this, we need to make a couple of changes


inside getServerSideProps, we will check if the category parameter is present

export async function getServerSideProps(context) {
    const {query} = context
    const {category} = query
    const queryString = category ? "category=sports" : ""
    const response = await axios.get(`http://localhost:4000/events?${queryString}`)

    return{
        props: {
            events: response.data
        }
    }
}



in the fetchSportsEvent handler, we need to push the category filter in the browser url using useRouter


in the push the second argument is going to be undefined as it is not necessary here and the 3rd argument we will set shallow routing to true

    const fetchSportsEvents = async () => {
        const response = await axios.get("http://localhost:4000/events?category=sports")
        setStateEvents(response.data)
        router.push("/events?category=sports", undefined, {shallow: true})
    }







points to note

we're not using array.filter in the pre rendered list of events because in a real world app with a huge list of events, we only pre-render some events. we need to refetch and filter from the list of all the existing events


we could have also used dynamic routing to handle this category filter. however when the filters are many e.g. in a site like amazon, filtering using client side data fetching and shallow routing is much simpler































